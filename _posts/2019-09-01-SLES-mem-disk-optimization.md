---
layout: post
title: SLES 11/12：内存、磁盘/存储IO调优
category: 计算机
tags: [计算机, 软件]
---


----------
本文档是内存和磁盘I/O调优和优化的基本SLES调优指南。讨论的许多参数和设置都是Linux通用的，可以应用。在实现调优参数之前，请参阅IHV/ISV应用程序调优指南或文档。

**在开始对服务器进行调优之前，请确保使用“sysctl -A”创建当前内核设置的备份:**

```
sysctl -A > /root/sysctl.settings.backup
```

**注意：**一些调优参数和配置会积极地提高性能。**因此，如果没有在指定的测试环境中进行适当的测试，就不应该在生产环境中应用这些设置。**


----------


## SLES内存调优

**在具有大内存的系统上禁用透明大页面(THP)：**频繁访问翻译后备缓冲区(TLB)可能会显著降低系统速度。虽然THP可以提高大量工作负载的性能，但是对于很少引用大量内存的工作负载，它可能会降低性能。要禁用THP引导系统与内核参数：

```
transparent_hugepage=never 
```

或

```
echo never > /sys/kernel/mm/transparent_hugepage/enabled
```

暂时停用THP。确认该设置是否已停用：

```
cat /sys/kernel/mm/transparent_hugepage/enabled
always madvise [never]
```

**大页面：**如果服务器是一个被大量使用的应用程序服务器，例如数据库，那么使用大页面会使它受益匪浅。SLES中默认的大页面大小为2mb，启用大页面将有助于对内存密集型应用程序/数据库、HPC机器进行重大改进，如果应用程序支持大页面，则需要执行此配置。如果应用程序不支持大页面，那么配置大页面将导致内存浪费，因为操作系统不能进一步使用它，默认情况下不会分配大页面。通过一下命令验证服务器没有分配任何巨大的页面：

```
cat /proc/sys/vm/nr_hugepages 
```

分配，例如128个2MB大小的大页面(分配256MB)，你可以通过grub把参数传递给内核：

```
hugepages=128 
```

重新启动后，确认128个大页面是否通过以下方式分配给服务器：

```
cat /proc/sys/vm/nr_hugepages
```

在SLES中配置大型页面的另一个推荐方法是安装oracleasm rpm。在文件/etc/sysconfig/oracle中，将参数从NR_HUGE_PAGES=0更改为**NR_HUGE_PAGES=128**，例如，如果您想添加128个大页面并重启oracle服务。

有关分配大量页面的最佳实践过程，请参阅ISV文档。分配太多的大页面可能会导致负载下的性能退化。

**交换改进：**如果使用了交换空间，您还应该查看**/proc/meminfo**文件，以便将交换的使用与不活动的匿名(anon)内存页的数量联系起来。如果使用的交换量大于**/proc/meminfo**中观察到的anon内存页的数量，则表明正在交换活动内存。这将降低性能，可以通过安装更多RAM来解决。如果使用的交换量小于**/proc/meminfo**中不活动的anon内存页的数量，则表明性能良好。但是，如果交换中的内存比不活动的匿名页面的数量还要多，那么由于正在交换活动内存，这会降低性能。它将表明太多的I/O流量，这可能会减慢您的系统。**Swappiness：**将Swappiness值从默认值60降低到25将减少操作系统交换内存的必要性，并将最大限度地使用您服务器上的内存：

```
echo 25 > /proc/sys/vm/swappiness
```

**VFS缓存：**为了降低回收VFS缓存的速度，最好将vfs_cache_pressure值从默认值100降低到50，这个变量控制内核回收用于VFS缓存的内存与用于页面缓存和交换的内存的趋势。

```
echo 50 > /proc/sys/vm/vfs_cache_pressure
```


**KSM：**内核版本2.6.32引入了**Kernel Samepage Merging(KSM)**。KSM允许应用程序向内核注册，以便将其内存页与其他进程合并，这些进程也注册以合并其页面。对于KVM, KSM机制允许客户虚拟机彼此共享页面。在今天的环境中，许多客户操作系统，如XEN, KVM是相似的，并运行在相同的主机上，这可以导致显着的内存节省，默认值设置为0，更改为1：

```
echo 1 > /sys/kernel/mm/ksm/run 
```

**内存过度提交：**每个Linux进程通常都试图占用超过其需要的内存。我们的目标是使这个过程更快。如果进程没有多余的内存，那么它需要请求内核为进程分配更多的内存，如果请求由于内存不足而不断发生，那么进程将变得更慢。overcommit_memory是一个可以调优以改进进程内存的参数。SLES中的默认值设置为0，这意味着内核在授予更多内存之前检查是否有可用内存，另外两个可用参数是overcommit_memory的1和2。将其更改为1将使系统的行为就像它没有检查就拥有所需的所有内存一样，而2意味着如果内核没有可用的内存，它将拒绝内存请求。如果系统被调优为具有应用程序进程所需的所有内存，那么一些应用程序的性能往往会更好，但是这也可能导致内存不足，从而调用内核OOM杀手。更改overcommit_memory可以通过：

```
echo 1 > /proc/sys/vm/overcommit_memory
```

如果选择的默认值0 overcommit_memory,提高性能的另一种方法是改变overcommit_ratio参数从系统默认50%比例更高价值,overcommit_ratio值50意味着内核可以总额的50%分配更多的内存可用内存(RAM +交换)。在一个有8 GB RAM和2 GB Swap的系统上，默认的过度提交百分比为50，可寻址内存的总量为15 GB。将overcommit_ratio更改为70%意味着将有更多的内存可用来过度提交进程：

```
echo 70 > /proc/sys/vm/overcommit_ratio
```

**drop_caches：**对系统有大量的内存,当服务器最终利用大量的内存和交换开始,它可能,虽然您的应用程序可能不使用这些内存但Linux是积极向它的内存缓存,即使应用程序需要的内存不会免费的一些缓存但是宁愿开始交换。
处理这样的随机问题,内核2.6.16后来发布时提供了一个非破坏性内核将页面缓存的机制,通过drop_caches inode和dentry缓存参数,这可以释放大量仍未使用但因某种原因不是由内核释放服务器重新启动的内存。

释放页面缓存：

```
echo 1 > /proc/sys/vm/drop_caches
```

释放目录项（dentries）和索引节点（inodes）：

```
echo 2 > /proc/sys/vm/drop_caches
```

释放页面缓存、目录项和索引节点

```
echo 3 > /proc/sys/vm/drop_caches
```

正如前面提到的，这个过程是非破坏性的，因此脏对象不会被释放，在释放pagecache、dentries和inode之前，最好先运行“sync”命令。


----------


## SLES磁盘I/O和存储调优

**脏比率：**如果在具有大内存(128GB+)的系统上观察到写性能问题，请更改dirty_ratio和dirty_background_ratio的内存百分比设置。

```
echo 10 > /proc/sys/vm/dirty_ratio
echo 5 > /proc/sys/vm/dirty_background_ratio
```

**IO调度器：** SLES的默认I/O调度器是CFQ。它为广泛的I/O任务提供了良好的性能，但是一些I/O任务对于某些类型的硬件或应用程序(如数据库)可以执行得更好，对于某些工作负载noop或deadline调度程序可以提高I/O性能，从而获得更好的结果。CFQ: CFQ是一个面向公平的调度程序，默认情况下在SUSE Linux Enterprise上使用。该算法为每个线程分配一个时间片，允许它将I/O提交到磁盘。通过这种方式，每个线程都获得了I/O吞吐量的公平份额。它还允许分配任务I/O优先级，这些优先级在调度决策时要考虑到。
NOOP: NOOP调度程序仅对数据执行最小的合并功能。没有排序，因此，这个调度程序的开销最小。该调度程序是为非基于磁盘的块设备(如内存设备、SSD)开发的。它在具有广泛缓存的存储介质上也做得很好。在某些情况下，它可以帮助那些自己进行I/O调度的设备，比如智能存储设备，或者不依赖机械移动的设备，比如ssd，因为NOOP调度程序的开销更少，它可以为某些工作负载提供更好的性能。

**Deadline：** Deadline调度程序可以处理5个不同的I/O队列，因此非常能够区分读请求和写请求。当使用这个调度程序时，读请求将获得更高的优先级。写请求没有截止日期，因此，要写的数据可以在缓存中保存更长的时间。在需要良好的读性能和写性能的环境中，这个调度程序表现得很好，但是对于读，它显示了更多的优先级。这个调度程序在数据库环境中表现得特别好。您可以一次使用一个调度器来实现系统范围的I/O性能，在激活noop调度器之前，请与您的硬件/存储供应商检查他们的存储系统管理I/O特性的能力。

可以以两种不同的方式启用I/O调度程序。

**a)** 要在引导期间在系统范围内启用I/O调度器，请在/boot/grub/menu.lst中添加以下参数：

```
elevator=noop or elevator=deadline
```

**b)** 若要为某些块设备启用特定的调度程序，可以将一个新值回显到：

```
/sys/block/<device name>/queue/scheduler
echo deadline > /sys/block/<device name>/queue/scheduler
```

启用特定的调度器允许您根据服务器上运行的工作负载的类型为特定块设备运行优化的I/O工作负载。例如，如果您的数据库位于块设备sdg上，您可以为块设备sdg启用deadline调度程序，而其他操作系统则继续使用默认的CFQ或NOOP IO调度程序。

**改进I/O读取：**虽然Deadline调度程序在读取和写入之间进行了平衡，但会有一点偏向于读取，但是可以使用read_ahead_kb和nr_request参数为每个磁盘上特定类型的应用程序的读取请求进一步优化操作系统。内核可以检测应用程序何时从文件或磁盘中顺序读取数据。在这种情况下它执行一个智能预读算法,比用户请求的数据从磁盘读取,当用户下一个尝试读取数据内核没有去取,但已经可以在页面缓存提高读取性能。在默认Linux安装中，read_ahead_kb值被设置为128或512。当然可以改进这一点，使读取性能更好，并将其设置为1024或2048(对于具有快速磁盘的服务器)。对于设备映射器设备，由于设备映射器有多个底层设备，因此可以将该值设置为高达8192，不过1024应该是一个很好的调优起点。类似地，nr_request默认值被设置为128，每个请求队列都对可以为每个读和写I/Os分配的请求描述符的总数有一个限制。也就是说，如果将默认值设置为128，那么在使进程休眠之前，一次只能排队处理128个读和写请求。为了获得更好的读取性能，您可以将nr_request值设置为1024，但是将该值设置得过高可能会导致延迟和降低写性能。对于延迟敏感的应用程序，情况也正好相反，nr_request值必须设置为低于默认值128(在某些情况下低至1)，以便writeback I/O不能分配所有可用的请求描述符，也不能用write I/O填充设备队列。要更改read_ahead_kb和nr_request的值，请尝试：

```
echo 1024 > /sys/block/<device name >/queue/read_ahead_kb
echo 1024 > /sys/block/<device name>/queue/nr_requests
```

**文件系统优化：** Linux上的所有现代文件系统都使用某种日志机制来在日期安全性和性能之间取得适当的平衡。SLES上的默认日志模式是data=ordered，它确保数据在写入日志之前被写到磁盘。为了提高文件系统在数据速度和安全性方面的性能，可以使用data=writeback。此选项可以确保内部文件系统的完整性，但不能保证将新文件写入磁盘。另一个选项是禁用barrier支持。在电源故障或崩溃的情况下，文件系统将不得不运行文件系统检查来修复结构。即使启用了barrier，大多数文件系统在出现电源故障或崩溃时仍然会运行fsck。使用data=writeback、barrier=0挂载文件系统可以提高文件系统的性能，但要付出一定的可靠性。一般来说，data=writeback应该足够好，可以在不禁用barrier的情况下增加一些性能增益。例如：编辑/etc/fstab

```
/dev/sdc   /SAP  ext3   acl,user_xattr, data=writeback  barrier=0    1 1
```

**Kdump：**在您的服务器上配置Kdump，并确保通过TID 3374462中记录的键盘参数对其进行测试以使其工作。Kdump虽然与优化服务器没有直接关系，但在服务器崩溃或挂起的情况下会很有用，在这种情况下，需要内核内存转储来分析OS崩溃/挂起的根本原因。与大量的服务器内存512 GB - 1 TB以上有足够的磁盘空间可用来收集内存转储KDUMP_DUMPLEVEL /etc/sysconfig/kdump文件的一个比较合理的值将是15日余额需要捕获的最大的数据转储保持转储大小合理使用时启用了默认值压缩kdump。Kdump:在您的服务器上配置Kdump，并确保通过TID 3374462中记录的键盘参数对其进行测试以使其工作。Kdump虽然与优化服务器没有直接关系，但在服务器崩溃或挂起的情况下会很有用，在这种情况下，需要内核内存转储来分析OS崩溃/挂起的根本原因。与大量的服务器内存512 GB - 1 TB以上有足够的磁盘空间可用来收集内存转储KDUMP_DUMPLEVEL /etc/sysconfig/kdump文件的一个比较合理的值将是15日余额需要捕获的最大的数据转储保持转储大小合理使用时启用了默认值压缩kdump。

